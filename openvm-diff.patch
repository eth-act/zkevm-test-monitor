diff --git a/crates/cli/src/commands/run.rs b/crates/cli/src/commands/run.rs
index 075427fb2..1e484f912 100644
--- a/crates/cli/src/commands/run.rs
+++ b/crates/cli/src/commands/run.rs
@@ -1,9 +1,9 @@
-use std::path::PathBuf;
+use std::{fs::read, path::PathBuf};
 
 use clap::{Parser, ValueEnum};
 use eyre::Result;
-use openvm_circuit::arch::{instructions::exe::VmExe, OPENVM_DEFAULT_INIT_FILE_NAME};
-use openvm_sdk::{config::SdkVmConfig, fs::read_object_from_file, keygen::AppProvingKey, Sdk, F};
+use openvm_circuit::arch::OPENVM_DEFAULT_INIT_FILE_NAME;
+use openvm_sdk::{config::SdkVmConfig, fs::read_object_from_file, keygen::AppProvingKey, Sdk};
 
 use super::{build, BuildArgs, BuildCargoArgs};
 use crate::{
@@ -266,13 +266,49 @@ impl RunCmd {
 
         let (manifest_path, manifest_dir) =
             get_manifest_path_and_dir(&self.cargo_args.manifest_path)?;
-        let config_path = self
-            .run_args
-            .config
-            .to_owned()
-            .unwrap_or_else(|| manifest_dir.join("openvm.toml"));
-        let app_config = read_config_toml_or_default(&config_path)?;
-        let exe: VmExe<F> = read_object_from_file(exe_path)?;
+
+        // Determine if we're running an ELF file - if so, use riscv32 config
+        let is_elf_file = exe_path.extension().and_then(|s| s.to_str()) == Some("elf");
+
+        let app_config = if is_elf_file {
+            // ELF files are RISC-V binaries - use riscv32 configuration with proper transpiler
+            use openvm_sdk::config::AppConfig;
+            AppConfig::riscv32()
+        } else {
+            // For vmexe files, read config from openvm.toml
+            let config_path = self
+                .run_args
+                .config
+                .to_owned()
+                .unwrap_or_else(|| manifest_dir.join("openvm.toml"));
+            read_config_toml_or_default(&config_path)?
+        };
+
+        // Read executable - support both .vmexe (bitcode) and .elf (raw ELF) files
+        let exe_bytes = if exe_path.extension().and_then(|s| s.to_str()) == Some("vmexe") {
+            // For .vmexe files, read as bitcode-encoded VmExe and re-encode as bytes
+            // This maintains backward compatibility with pre-built vmexe files
+            use openvm_circuit::arch::instructions::exe::VmExe;
+            use openvm_sdk::F;
+            let exe: VmExe<F> = read_object_from_file(exe_path)?;
+            // Convert to ExecutableFormat by wrapping in Arc and using that
+            // Actually, just pass the VmExe directly - it implements Into<ExecutableFormat>
+            return self.run_with_exe(exe, app_config, manifest_path, manifest_dir);
+        } else {
+            // For ELF files, read raw bytes
+            read(exe_path)?
+        };
+
+        self.run_with_bytes(exe_bytes, app_config, manifest_path, manifest_dir)
+    }
+
+    fn run_with_exe(
+        &self,
+        exe: openvm_circuit::arch::instructions::exe::VmExe<openvm_sdk::F>,
+        app_config: openvm_sdk::config::AppConfig<SdkVmConfig>,
+        manifest_path: PathBuf,
+        manifest_dir: PathBuf,
+    ) -> Result<()> {
         let inputs = read_to_stdin(&self.run_args.input)?;
 
         // Create SDK
@@ -327,4 +363,66 @@ impl RunCmd {
 
         Ok(())
     }
+
+    fn run_with_bytes(
+        &self,
+        exe_bytes: Vec<u8>,
+        app_config: openvm_sdk::config::AppConfig<SdkVmConfig>,
+        manifest_path: PathBuf,
+        manifest_dir: PathBuf,
+    ) -> Result<()> {
+        let inputs = read_to_stdin(&self.run_args.input)?;
+
+        // Create SDK
+        let sdk = Sdk::new(app_config)?;
+
+        // For metered modes, load existing app pk from disk or generate it
+        if matches!(
+            self.run_args.mode,
+            ExecutionMode::Segment | ExecutionMode::Meter
+        ) {
+            let target_dir = get_target_dir(&self.cargo_args.target_dir, &manifest_path);
+            let app_pk_path = get_app_pk_path(&target_dir);
+            let app_vk_path = get_app_vk_path(&target_dir);
+
+            // Generate app pk if it doesn't exist
+            if !app_pk_path.exists() {
+                let config_path = self
+                    .run_args
+                    .config
+                    .to_owned()
+                    .unwrap_or_else(|| manifest_dir.join("openvm.toml"));
+                keygen(&config_path, &app_pk_path, &app_vk_path, None::<&str>)?;
+            }
+
+            // Load the app pk and set it
+            let app_pk: AppProvingKey<SdkVmConfig> = read_object_from_file(&app_pk_path)?;
+            sdk.set_app_pk(app_pk)
+                .map_err(|_| eyre::eyre!("Failed to set app pk"))?;
+        }
+
+        match self.run_args.mode {
+            ExecutionMode::Pure => {
+                let output = sdk.execute(exe_bytes, inputs)?;
+                println!("Execution output: {:?}", output);
+            }
+            ExecutionMode::Meter => {
+                let (output, (cost, instret)) = sdk.execute_metered_cost(exe_bytes, inputs)?;
+                println!("Execution output: {:?}", output);
+
+                println!("Number of instructions executed: {}", instret);
+                println!("Total cost: {}", cost);
+            }
+            ExecutionMode::Segment => {
+                let (output, segments) = sdk.execute_metered(exe_bytes, inputs)?;
+                println!("Execution output: {:?}", output);
+
+                let total_instructions: u64 = segments.iter().map(|s| s.num_insns).sum();
+                println!("Number of instructions executed: {}", total_instructions);
+                println!("Total segments: {}", segments.len());
+            }
+        }
+
+        Ok(())
+    }
 }
